---
layout: post
title:  "test"
date:   2017-08-23 11:36:23 +0700
categories: [Linear_Algebra, python, LaTeX]
---

## 행렬 지수 함수  Exponential 지수 연산

- 지수 연산은 power series를 이용한다.
> **power series란?**
>> $$ e^{x} = \sum_{n=0}^\infty{1 \over n!}x^n = 1 + x + \dfrac{1}{2!}x^2 + \dfrac{1}{3!}x^3 + \cdots $$

- 위의 식에 $$ x \leftarrow \mathbf{X}$$ 대입하면 다음과 같다.
> $$ e^{\mathbf{X}} = \sum_{k=0}^\infty{1 \over k!}\mathbf{X}^k = I + \mathbf{X} + \dfrac{1}{2!}\mathbf{X}^2 + \dfrac{1}{3!}\mathbf{X}^3 + \cdots $$
> 
> 
>  - 위의 식이 성립하기 위해서 다음이 성립한다고 약속을 하자.
$$ \mathbf{X}^0 = \mathbf{I} $$
> 
> 
> - 또한,  $$e^{\mathbf{X}}$$ 를 **행렬 지수 함수**라고 한다.
> 
> 
> 
> - **행렬 지수 함수**
>> - $$ exp: M_{n \times n} \rightarrow M_{n \times n} $$ 은 **정사각 행렬**을 다른 **정사각 행렬**로 보내는 행렬 함수
>>  
>> - 위의 급수는 항상 수렴하므로, 행렬 지수는 항상 존재한다.

- 행렬 지수 함수는 다음 성질을 만족한다.
> $$ e^{a\mathbf{X}}\; =\; e^a  e^\mathbf{X} $$
>> $$ a $$ : 상수(스칼라)
>
>
> - 만약 $$\mathbf{XY} = \mathbf{YX}$$ 이면
>> $$ e^{\mathbf{X} + \mathbf{Y}} = e^\mathbf{X} \cdot e^\mathbf{Y} $$
>>
>> $$ e^{a\mathbf{X}}e^{b\mathbf{X}} = e^{(a+b)\mathbf{X}} $$
> - 교환법칙이 성립하면 지수함수의 성질이 행렬 지수 함수에도 동일하게 적용된다.

### 간단하게 실습해보자.


```python
# -*- coding: utf-8 -*-

import numpy as np
```


```python
A = np.ones(3) + np.diag(np.arange(1, 4)) 
A
```




    array([[ 2.,  1.,  1.],
           [ 1.,  3.,  1.],
           [ 1.,  1.,  4.]])




```python
np.exp(A)
```




    array([[  7.3890561 ,   2.71828183,   2.71828183],
           [  2.71828183,  20.08553692,   2.71828183],
           [  2.71828183,   2.71828183,  54.59815003]])




```python
B = np.eye(3)
B
```




    array([[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]])




```python
np.dot(A,B)
```




    array([[ 2.,  1.,  1.],
           [ 1.,  3.,  1.],
           [ 1.,  1.,  4.]])




```python
np.dot(B,A)
```




    array([[ 2.,  1.,  1.],
           [ 1.,  3.,  1.],
           [ 1.,  1.,  4.]])



### $$ AB = BA $$
- 교환 법칙이 성립한다.


```python
np.exp(A+B)
```




    array([[  20.08553692,    2.71828183,    2.71828183],
           [   2.71828183,   54.59815003,    2.71828183],
           [   2.71828183,    2.71828183,  148.4131591 ]])




```python
np.exp(A) * np.exp(B)
```




    array([[  20.08553692,    2.71828183,    2.71828183],
           [   2.71828183,   54.59815003,    2.71828183],
           [   2.71828183,    2.71828183,  148.4131591 ]])



### $$ e^{\mathbf{A} + \mathbf{B}} = e^\mathbf{A} \cdot e^\mathbf{B} $$
- 성립하는 것을 확인할 수 있다.

---

## Inverse 역행렬
> #### 정방행렬에서만 가능!!


$$ A \; \in \; R^{M \times M} $$

$$ A^{-1} A \; = \; A A^{-1} \; = \; I $$

$$ (AB)^{-1} \; = \; B^{-1} A^{-1} $$


```python
A = np.array([[2, 1, 0], [1, 0, -1], [3, 2, 0]])
A
```




    array([[ 2,  1,  0],
           [ 1,  0, -1],
           [ 3,  2,  0]])




```python
A_inv = np.linalg.inv(A) # 역행렬을 직접 구하는 메소드는 실제로 잘 사용하지 않는다. ∵ 역행렬을 구할 때 오차가 크기 때문에
A_inv
```




    array([[ 2.,  0., -1.],
           [-3., -0.,  2.],
           [ 2., -1., -1.]])




```python
np.dot(A, A_inv)
```




    array([[  1.00000000e+00,   0.00000000e+00,   0.00000000e+00],
           [  0.00000000e+00,   1.00000000e+00,   2.22044605e-16],
           [  0.00000000e+00,   0.00000000e+00,   1.00000000e+00]])




```python
np.dot(A_inv, A)
```




    array([[  1.00000000e+00,   4.44089210e-16,   0.00000000e+00],
           [ -1.77635684e-15,   1.00000000e+00,   0.00000000e+00],
           [  0.00000000e+00,   0.00000000e+00,   1.00000000e+00]])



 

$$ A^{-1} A \; = \; A A^{-1} \; = \; I $$ 가 성립하는 것을 확인할 수 있다.

## System of Equations 연립방정식

$$ \begin{matrix} a_{11} x_1 \;\;\;\; + \;\;\;\;\; a_{12} x_2   \;\;\;\;\; + \cdots + \;\;\;\;\; a_{1M} x_M \;\;\;\;\; = \;\;\;\;\; b_1 \\ a_{21} x_1 \;\;\;\; + \;\;\;\;\; a_{22} x_2   \;\;\;\;\; + \cdots + \;\;\;\;\; a_{2M} x_M \;\;\;\;\; = \;\;\;\;\; b_2 \\ \vdots\;\;\; \;\;\;\;   \;\;\;\; \vdots\;\;\; \;\;\;\;   \;\;\;\; \vdots\;\;\; \;\;\;\;     \;\;\;\; \;\vdots \\ a_{N1} x_1 \;\;\;\; + \;\;\;\;\; a_{N2} x_2   \;\;\;\;\; + \cdots + \;\;\;\;\; a_{NM} x_M \;\;\;\;\; = \;\;\;\;\; b_N \end{matrix} $$


$$ \begin{bmatrix} a_{11} \;\;\;\; a_{12} \;\;\;\; \cdots \;\;\;\; a_{1M} \\ a_{21} \;\;\;\; a_{22} \;\;\;\; \cdots \;\;\;\; a_{2M} \\ \vdots \;\;\;\; \vdots \;\;\;\; \ddots \;\;\;\; \vdots \\ a_{N1} \;\;\;\; a_{N2} \;\;\;\; \cdots \;\;\;\; a_{NM} \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_M
\end{bmatrix} = \begin{bmatrix} b_1 \\ b_2 \\ \vdots \\ b_N \end{bmatrix} $$

$$ \mathbf{Ax} = \mathbf{b} $$

$$\mathbf{A} : N * M \\ \mathbf{x} : M * 1 \\ \mathbf{b} : N * 1 $$

- 일반적으로 데이터분석에서는 feature(M)보다 sample(N)의 수가 더 많다.

N = M 이고,  $$ \;\; A^{-1} $$가 존재 $$\;\;\;$$ ➔    $$ \;\;\; \mathbf{x} \; = \; \mathbf{A}^{-1} \mathbf{b} $$

- 간단한 예제를 풀어보자.


```python
A = np.array([[1, 3, -2], [3, 5, 6], [2, 4, 3]])
A
```




    array([[ 1,  3, -2],
           [ 3,  5,  6],
           [ 2,  4,  3]])




```python
b = np.array([[5], [7], [8]])
b
```




    array([[5],
           [7],
           [8]])



### Solution of System of Equations (Square Matrix)

* $$N = M$$ $$\;$$ → $$\;$$ 정방행렬인 경우 역행렬을 양변에 곱하여 해를 구하면 된다.

$$ \mathbf{x} = \mathbf{A}^{-1} \mathbf{b} $$


```python
A_inv = np.linalg.inv(A)
A_inv
```




    array([[ 2.25,  4.25, -7.  ],
           [-0.75, -1.75,  3.  ],
           [-0.5 , -0.5 ,  1.  ]])




```python
x = np.dot(A_inv,b)
```


```python
x
```




    array([[-15.],
           [  8.],
           [  2.]])




```python
np.dot(A,x)
```




    array([[ 5.],
           [ 7.],
           [ 8.]])



$$ \mathbf{Ax} = \mathbf{b} \;$$가 성립하는 것을 확인할 수 있다.

---

### Least Square Minimization of System of Equations ( 오차의 최소제곱법)

* $$ \bbox[15px, border:2px solid red]{N > M} $$ → $$\;$$정방행렬이 아니다!
    - A ← 정방행렬이 아니다.$$\; (N * M)$$
    - $$ \bbox[15px, border:2px solid red]{\mathbf{A}^T \mathbf{A} } $$ ➔ $$(M * N) \;*\; (N * M)$$  ➔ 정방행렬

$$ \mathbf{e}^T\mathbf{e} = (\mathbf{A}\mathbf{x}-\mathbf{b})^T(\mathbf{A}\mathbf{x}-\mathbf{b}) $$
- **Minimize** 

$$ \mathbf{A}^T\mathbf{A}\mathbf{x} = \mathbf{A}^T\mathbf{b} $$

$$ \bbox[15px, border:2px solid red]{\mathbf{x} = (\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T \mathbf{b}} $$

이때, $$\mathbf{x}$$의 값은 $$ \mathbf{e}^T\mathbf{e} = (\mathbf{A}\mathbf{x}-\mathbf{b})^T(\mathbf{A}\mathbf{x}-\mathbf{b})$$의 최소값이다.


```python
A = np.array([[2, 0], [-1, 1], [0, 2]])
A
```




    array([[ 2,  0],
           [-1,  1],
           [ 0,  2]])




```python
b = np.array([[1], [0], [-1]])
b
```




    array([[ 1],
           [ 0],
           [-1]])




```python
A_inv = np.linalg.inv(A)
```


    ---------------------------------------------------------------------------

    LinAlgError                               Traceback (most recent call last)

    <ipython-input-21-f1831ccb7f4e> in <module>()
    ----> 1 A_inv = np.linalg.inv(A)
    

    ~/.pyenv/versions/anaconda3-4.0.0/envs/code_study/lib/python3.6/site-packages/numpy/linalg/linalg.py in inv(a)
        506     a, wrap = _makearray(a)
        507     _assertRankAtLeast2(a)
    --> 508     _assertNdSquareness(a)
        509     t, result_t = _commonType(a)
        510 


    ~/.pyenv/versions/anaconda3-4.0.0/envs/code_study/lib/python3.6/site-packages/numpy/linalg/linalg.py in _assertNdSquareness(*arrays)
        210     for a in arrays:
        211         if max(a.shape[-2:]) != min(a.shape[-2:]):
    --> 212             raise LinAlgError('Last 2 dimensions of the array must be square')
        213 
        214 def _assertFinite(*arrays):


    LinAlgError: Last 2 dimensions of the array must be square


- **정방행렬이 아니기 때문에 역행렬이 존재하지 않는다.**
    - 위 코드에서도 에러가 뜬다.
    
- **$$ \mathbf{A}^T \mathbf{A} $$**는 역행렬이 존재하므로 이를 활용해야 한다.


```python
np.dot(A.T,A)
```




    array([[ 5, -1],
           [-1,  5]])




```python
np.linalg.inv(np.dot(A.T,A))
```




    array([[ 0.20833333,  0.04166667],
           [ 0.04166667,  0.20833333]])




```python
np.dot(np.linalg.inv(np.dot(A.T,A)), A.T)
```




    array([[ 0.41666667, -0.16666667,  0.08333333],
           [ 0.08333333,  0.16666667,  0.41666667]])




```python
x = np.dot(np.dot(np.linalg.inv(np.dot(A.T,A)), A.T),b)
```


```python
x
```




    array([[ 0.33333333],
           [-0.33333333]])




```python
np.dot(A, x)
```




    array([[ 0.66666667],
           [-0.66666667],
           [-0.66666667]])




```python
b
```




    array([[ 1],
           [ 0],
           [-1]])



- 실제값과 오차가 많이 나는 것을 확인할 수 있다.

## Trace(대각합)

> - 행렬의 특성을 결정하는 숫자 중 하나
> - 정방 행렬에 대해서 정의
> - 대각 성분의 합

$$ \text{tr} (\mathbf{A}) = \sum_{i=1}^M a_{ii} $$


```python
A = np.ones(3) + np.diag([1, 2, 3])
A
```




    array([[ 2.,  1.,  1.],
           [ 1.,  3.,  1.],
           [ 1.,  1.,  4.]])




```python
np.ones([3,3]) + np.diag([1, 2, 3])
```




    array([[ 2.,  1.,  1.],
           [ 1.,  3.,  1.],
           [ 1.,  1.,  4.]])




```python
np.trace(A)
```




    9.0



### Trace 성질

> $$ \text{tr} (cA) = c\text{tr} (A) $$
> 
> $$ \text{tr} (A^T) = \text{tr} (A) $$
> 
> $$ \text{tr} (A + B) = \text{tr} (A) + \text{tr} (B)$$
> 
> $$ \text{tr} (AB) = \text{tr} (BA) $$
> 
> $$ \text{tr} (ABC) = \text{tr} (BCA) = \text{tr} (CAB) $$
>> $$ABC \; BCA \; CAB $$ 이 순서로만 만족한다.

###  trace trick


> $$ x^TAx = \text{tr}(x^TAx) = \text{tr}(Axx^T)  = \text{tr}(xx^TA) $$
>> $$ \bbox[15px, border:2px solid darkred]{x^TAx} $$ ➔ 스칼라!!

## Determinant 행렬식

* 행렬의 특성을 결정하는 숫자 중 하나
* 정방 행렬에 대해서 정의
 

1×1 행렬의 행렬식

$$\det\begin{bmatrix}a\end{bmatrix}=a$$

2×2 행렬의 행렬식
$$\det\begin{bmatrix}a\;\;\;\;b\\c\;\;\;\;d\end{bmatrix}=ad-bc$$

3×3 행렬의 행렬식
$$\det\begin{bmatrix}a\;\;\;\;b\;\;\;\;c\\d\;\;\;\;e\;\;\;\;f\\g\;\;\;\;h\;\;\;\;i\end{bmatrix}=aei+bfg+cdh-ceg-bdi-afh$$

> 3×3 행렬의 행렬식
>> - $$ \det\begin{bmatrix}a\;\;\;\;b\;\;\;\;c\\d\;\;\;\;e\;\;\;\;f\\g\;\;\;\;h\;\;\;\;i\end{bmatrix} \; = \; aei+bfg+cdh-ceg-bdi-afh $$

- 아래처럼 1열, 2열을 원래 행렬 옆에 써두고 대각선끼리 곱해서 계산하면 쉽게 공식을 외울 수 있다.

> 3×3 행렬의 행렬식
>> $$ \begin{bmatrix}a\;\;\;\;b\;\;\;\;c\\d\;\;\;\;e\;\;\;\;f\\g\;\;\;\;h\;\;\;\;i\end{bmatrix} \begin{bmatrix}a\;\;\;\;b \\ d\;\;\;\;e \\ g\;\;\;\;h \end{bmatrix} $$


```python
A = np.random.randn(3, 3)
A
```




    array([[-2.03388099, -0.3303605 ,  0.03250663],
           [-1.19379899, -0.76508161,  1.85158487],
           [ 1.36613416,  1.74855998,  0.85649014]])




```python
np.linalg.det(A)
```




    6.7103626203738127
